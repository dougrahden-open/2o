# maurogpt2-training.py - PDF Processing and Embedding Training

# %% Cell 1: Imports and Dependencies

import os
import re
from pathlib import Path
from PyPDF2 import PdfReader
from sentence_transformers import SentenceTransformer
import chromadb
from chromadb.config import Settings
import shutil
import torch

# %% Cell 2: Configuration - Change base directory here for different environments

BASE_DIR = Path("D:/aa039v2")
MODELS_DIR = BASE_DIR / "models"
INPUTS_DIR = BASE_DIR / "inputs"
RAW_PDFS_DIR = INPUTS_DIR / "raw-pdfs"
PREPPED_PDFS_DIR = INPUTS_DIR / "prepped-pdfs"
ENGINE_DIR = BASE_DIR / "Engine"

# Model paths
BGE_MODEL_PATH = MODELS_DIR / "bge-large-en-v15"
COLLECTION_NAME = "pdf_collection"

print("[Setup] Base directories and model paths initialized")

# %% Cell 3: Directory Setup Functions

def setup_directories():
    """Create all necessary directories if they donâ€™t exist"""
    for directory in [INPUTS_DIR, RAW_PDFS_DIR, PREPPED_PDFS_DIR, ENGINE_DIR]:
        directory.mkdir(parents=True, exist_ok=True)
        print(f"[Setup] Ensured directory exists: {directory}")
    print(f"[Setup] All directories created or already exist in: {BASE_DIR}")

# %% Cell 4: PDF Selection Logic with Version Control

def get_latest_pdfs():
    """
    Get the latest version of each PDF based on:
    1. Suffix priority: _A -> _B -> _C -> _D -> _0 -> _1 -> _2 -> etc.
    2. File modification date (newest wins)
    """
    pdf_groups = {}
    print("[PDF Selection] Scanning for PDFs in:", RAW_PDFS_DIR)

    for pdf_file in RAW_PDFS_DIR.glob("*.pdf"):
        filename = pdf_file.stem
        mod_time = pdf_file.stat().st_mtime

        if re.match(r'.*_[A-Z]$', filename):
            base_name = filename[:-2]
            suffix_char = filename[-1]
            suffix = ord(suffix_char) - ord('A')
            suffix_type = 'letter'
        elif re.match(r'.*_\d+$', filename):
            parts = filename.rsplit('_', 1)
            base_name = parts[0]
            suffix = int(parts[1])
            suffix_type = 'number'
        else:
            base_name = filename
            suffix = -1
            suffix_type = 'base'

        if base_name not in pdf_groups:
            pdf_groups[base_name] = []
        pdf_groups[base_name].append((suffix_type, suffix, mod_time, pdf_file))

    latest_pdfs = []
    print("[PDF Selection] Grouping and selecting latest versions...")
    for base_name, versions in pdf_groups.items():
        def sort_key(item):
            suffix_type, suffix, mod_time, file_path = item
            if suffix_type == 'number':
                return (2, suffix, mod_time)
            elif suffix_type == 'letter':
                return (1, suffix, mod_time)
            else:
                return (0, suffix, mod_time)

        sorted_versions = sorted(versions, key=sort_key, reverse=True)
        latest_file = sorted_versions[0][3]
        latest_suffix = sorted_versions[0][1]
        latest_type = sorted_versions[0][0]

        if latest_type == 'number':
            suffix_desc = f"_{latest_suffix}"
        elif latest_type == 'letter':
            suffix_desc = f"_{chr(latest_suffix + ord('A'))}"
        else:
            suffix_desc = "(base)"

        latest_pdfs.append(latest_file)
        print(f"[PDF Selection] Selected: {latest_file.name} {suffix_desc} (from {len(versions)} versions)")

    return latest_pdfs

# %% Cell 5: PDF Preparation and Update Detection

def prepare_pdfs():
    """Copy latest PDFs to prepped directory, only if updates are needed"""
    print("[Prep] Checking for latest PDFs...")
    latest_pdfs = get_latest_pdfs()

    if not latest_pdfs:
        print("[Prep] No PDFs found in raw directory!")
        return []

    existing_prepped = list(PREPPED_PDFS_DIR.glob("*.pdf")) if PREPPED_PDFS_DIR.exists() else []
    print(f"[Prep] Found {len(existing_prepped)} existing prepped PDFs")

    needs_update = False

    if len(existing_prepped) != len(latest_pdfs):
        needs_update = True
        print(f"[Prep] File count changed: {len(existing_prepped)} -> {len(latest_pdfs)}")
    else:
        existing_names = {f.name for f in existing_prepped}
        latest_names = {f.name for f in latest_pdfs}

        if existing_names != latest_names:
            needs_update = True
            print("[Prep] File names differ, update required")
        else:
            for latest_pdf in latest_pdfs:
                prepped_file = PREPPED_PDFS_DIR / latest_pdf.name
                if prepped_file.exists():
                    latest_mod_time = latest_pdf.stat().st_mtime
                    prepped_mod_time = prepped_file.stat().st_mtime
                    if latest_mod_time > prepped_mod_time:
                        needs_update = True
                        print(f"[Prep] Newer version detected: {latest_pdf.name}")
                        break
                else:
                    needs_update = True
                    print(f"[Prep] Missing file: {latest_pdf.name}")
                    break

    if not needs_update:
        print("[Prep] No updates needed - all files are current")
        return latest_pdfs

    if PREPPED_PDFS_DIR.exists():
        shutil.rmtree(PREPPED_PDFS_DIR)
        print("[Prep] Old prepped directory cleared")
    PREPPED_PDFS_DIR.mkdir(parents=True, exist_ok=True)

    for pdf_file in latest_pdfs:
        dest_path = PREPPED_PDFS_DIR / pdf_file.name
        shutil.copy2(pdf_file, dest_path)
        print(f"[Prep] Copied: {pdf_file.name}")

    print(f"[Prep] Prepared {len(latest_pdfs)} PDFs in {PREPPED_PDFS_DIR}")
    return latest_pdfs
