# maurogpt2-training.py - PDF Processing and Embedding Training

# %% Cell 1: Imports and Dependencies

import os
import re
from pathlib import Path
from PyPDF2 import PdfReader
from sentence_transformers import SentenceTransformer
import chromadb
from chromadb.config import Settings
import shutil
import torch
import gc
from datetime import datetime

# %% Cell 2: Configuration - Change base directory here for different environments

BASE_DIR = Path("D:/aa039v2")
MODELS_DIR = BASE_DIR / "models"
INPUTS_DIR = BASE_DIR / "inputs"
RAW_PDFS_DIR = INPUTS_DIR / "raw-pdfs"
PREPPED_PDFS_DIR = INPUTS_DIR / "prepped-pdfs"
ENGINE_DIR = BASE_DIR / "Engine"

BGE_MODEL_PATH = MODELS_DIR / "bge-large-en-v15"
COLLECTION_NAME = "pdf_collection"

EMBEDDING_BATCH_SIZE = 256
STORAGE_BATCH_SIZE = 2000
CHUNK_SIZE = 400
USE_FP16 = True

FORCE_RETRAIN = False
SKIP_UPDATE_CHECK = False

# %% Cell 3: Directory Setup Functions

def setup_directories():
    directories = [INPUTS_DIR, RAW_PDFS_DIR, PREPPED_PDFS_DIR, ENGINE_DIR]
    for directory in directories:
        directory.mkdir(parents=True, exist_ok=True)
    print(f"Directories set up in: {BASE_DIR}")

    for dir_name, dir_path in [
        ("Raw PDFs", RAW_PDFS_DIR),
        ("Prepped PDFs", PREPPED_PDFS_DIR),
        ("ChromaDB", ENGINE_DIR)
    ]:
        if dir_path.exists():
            file_count = len(list(dir_path.glob("*")))
            print(f"  {dir_name}: {file_count} files")

# %% Cell 4: PDF Selection Logic with Version Control

def get_latest_pdfs():
    print("Scanning for PDFs...")
    pdf_groups = {}

    for pdf_file in RAW_PDFS_DIR.glob("*.pdf"):
        filename = pdf_file.stem
        mod_time = pdf_file.stat().st_mtime

        if re.match(r'.*_[A-Z]$', filename):
            base_name = filename[:-2]
            suffix_char = filename[-1]
            suffix = ord(suffix_char) - ord('A')
            suffix_type = 'letter'
        elif re.match(r'.*_\d+$', filename):
            parts = filename.rsplit('_', 1)
            base_name = parts[0]
            suffix = int(parts[1])
            suffix_type = 'number'
        else:
            base_name = filename
            suffix = -1
            suffix_type = 'base'

        if base_name not in pdf_groups:
            pdf_groups[base_name] = []
        pdf_groups[base_name].append((suffix_type, suffix, mod_time, pdf_file))

    if not pdf_groups:
        print(f"No PDFs found in {RAW_PDFS_DIR}")
        return []

    latest_pdfs = []
    for base_name, versions in pdf_groups.items():
        def sort_key(item):
            suffix_type, suffix, mod_time, file_path = item
            if suffix_type == 'number':
                return (2, suffix, mod_time)
            elif suffix_type == 'letter':
                return (1, suffix, mod_time)
            else:
                return (0, suffix, mod_time)

        sorted_versions = sorted(versions, key=sort_key, reverse=True)
        latest_file = sorted_versions[0][3]
        latest_suffix = sorted_versions[0][1]
        latest_type = sorted_versions[0][0]

        if latest_type == 'number':
            suffix_desc = f"_{latest_suffix}"
        elif latest_type == 'letter':
            suffix_desc = f"_{chr(latest_suffix + ord('A'))}"
        else:
            suffix_desc = "(base)"

        latest_pdfs.append(latest_file)
        print(f"Selected: {latest_file.name} {suffix_desc} (from {len(versions)} versions)")

    return latest_pdfs

# %% Cell 5: PDF Preparation and Update Detection

def prepare_pdfs():
    latest_pdfs = get_latest_pdfs()

    if not latest_pdfs:
        print("No PDFs found in raw directory!")
        return []

    if FORCE_RETRAIN:
        print("FORCE_RETRAIN enabled - rebuilding everything")
        if PREPPED_PDFS_DIR.exists():
            shutil.rmtree(PREPPED_PDFS_DIR)
        PREPPED_PDFS_DIR.mkdir(parents=True, exist_ok=True)

        for pdf_file in latest_pdfs:
            dest_path = PREPPED_PDFS_DIR / pdf_file.name
            shutil.copy2(pdf_file, dest_path)
            print(f"  Copied: {pdf_file.name}")

        print(f"Prepared {len(latest_pdfs)} PDFs (forced rebuild)")
        return latest_pdfs

    existing_prepped = []
    if PREPPED_PDFS_DIR.exists():
        existing_prepped = list(PREPPED_PDFS_DIR.glob("*.pdf"))

    needs_update = False

    if len(existing_prepped) != len(latest_pdfs):
        needs_update = True
        print(f"File count changed: {len(existing_prepped)} -> {len(latest_pdfs)}")
    else:
        existing_names = {f.name for f in existing_prepped}
        latest_names = {f.name for f in latest_pdfs}

        if existing_names != latest_names:
            needs_update = True
            print("Different files selected")
        elif not SKIP_UPDATE_CHECK:
            for latest_pdf in latest_pdfs:
                prepped_file = PREPPED_PDFS_DIR / latest_pdf.name
                if prepped_file.exists():
                    latest_mod_time = latest_pdf.stat().st_mtime
                    prepped_mod_time = prepped_file.stat().st_mtime
                    if latest_mod_time > prepped_mod_time:
                        needs_update = True
                        print(f"Newer version detected: {latest_pdf.name}")
                        break
                else:
                    needs_update = True
                    print(f"Missing file: {latest_pdf.name}")
                    break
        else:
            print("SKIP_UPDATE_CHECK enabled - ignoring file dates")

    if not needs_update:
        print("No updates needed - all files are current")
        return latest_pdfs

    if PREPPED_PDFS_DIR.exists():
        shutil.rmtree(PREPPED_PDFS_DIR)
    PREPPED_PDFS_DIR.mkdir(parents=True, exist_ok=True)

    for pdf_file in latest_pdfs:
        dest_path = PREPPED_PDFS_DIR / pdf_file.name
        shutil.copy2(pdf_file, dest_path)
        print(f"  Copied: {pdf_file.name}")

    print(f"Prepared {len(latest_pdfs)} PDFs in {PREPPED_PDFS_DIR}")
    return latest_pdfs
